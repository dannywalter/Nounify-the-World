<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- ensure mobile viewport sizing -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Platformer Game</title>
    <!-- p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <!-- Farcade SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <!-- Keyboard Input Tracker (Inline) -->
    <script>
      // KeyTracker - A simple module to track key states regardless of canvas focus
      class KeyTracker {
        constructor() {
          this.keys = {};
          this._setupEventListeners();
        }

        // Set up global keyboard listeners
        _setupEventListeners() {
          // Track key down events
          window.addEventListener("keydown", (e) => {
            this.keys[e.keyCode] = true;
            this.keys[e.key.toLowerCase()] = true;
          });

          // Track key up events
          window.addEventListener("keyup", (e) => {
            this.keys[e.keyCode] = false;
            this.keys[e.key.toLowerCase()] = false;
          });

          // Clear keys when window loses focus
          window.addEventListener("blur", () => {
            this.keys = {};
          });
        }

        // Check if a key is pressed
        isKeyDown(keyCode) {
          // Accept either key codes or key strings
          if (typeof keyCode === "string") {
            return this.keys[keyCode.toLowerCase()] === true;
          }
          return this.keys[keyCode] === true;
        }
      }

      // Create a singleton instance
      const keyTracker = new KeyTracker();
    </script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #333;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
        touch-action: none;
        -ms-touch-action: none;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .game-container {
        width: 100%;
        max-width: 500px;
        aspect-ratio: 500/800;
        position: relative;
      }

      .game-container canvas {
        width: 100%;
        height: 100%;
        display: block;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
        touch-action: none;
        -ms-touch-action: none;
      }

      /* Prevent text selection via dragging */
      * {
        -webkit-user-drag: none;
        -moz-user-drag: none;
        user-drag: none;
      }
      /* Custom loading screen styles */
      .p5_loading {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex !important;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #63a0f9;
        z-index: 1000;
        color: white;
        font-family: Arial, sans-serif;
      }

      .loading-title {
        font-size: 2.5rem;
        font-weight: bold;
        margin-bottom: 1rem;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .loading-bar-container {
        width: 80%;
        height: 20px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        overflow: hidden;
      }

      .loading-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(to right, #ffc110, #ff1ad2);
        border-radius: 10px;
        transition: width 0.3s ease;
      }

      .loading-text {
        margin-top: 0.5rem;
        font-size: 1rem;
      }

      /* Loading animation */
      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      .loading-character {
        margin: 20px 0;
        animation: bounce 1.5s infinite ease-in-out;
      }

      /* Fade-out transition when loaded */
      .p5_loading {
        transition: opacity 0.5s ease-out;
      }

      .p5_loading.loaded {
        opacity: 0;
      }
    </style>
  </head>
  <body>
    <div class="game-container" id="game-container">
      <!-- Custom loading screen -->
      <div id="p5_loading" class="p5_loading">
        <div class="loading-title">PLATFORMER ADVENTURE</div>
        <div class="loading-character">
          <!-- Simple character placeholder -->
          <svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="10" y="8" width="28" height="32" rx="4" fill="#FFD700" />
            <circle cx="20" cy="20" r="4" fill="#000" />
            <circle cx="28" cy="20" r="4" fill="#000" />
            <path d="M18 30C20 34 28 34 30 30" stroke="#000" stroke-width="2" stroke-linecap="round" />
          </svg>
        </div>
        <div class="loading-bar-container">
          <div id="loading-progress-bar" class="loading-bar"></div>
        </div>
        <div id="loading-text" class="loading-text">Loading game assets...</div>
      </div>
    </div>
    <script>
      // ── STATE‑WATCHER SETUP ──
      let _prevState = "";

      // Debounce for throw mechanic
      let lastThrowTime = 0;
      const THROW_COOLDOWN = 300; // milliseconds between throws

      // Track which touch/click events have already been processed
      let activeTouchIds = {};

      // Custom map function to ensure it's available even if p5.js map function isn't
      function customMap(value, start1, stop1, start2, stop2) {
        // Make sure we don't divide by zero
        if (stop1 === start1) return start2;
        // Calculate the mapped value using the correct formula
        return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
      }

      // — Farcade SDK event handlers —
      if (window.FarcadeSDK) {
        window.FarcadeSDK.on("play_again", () => {
          console.log("[DEBUG] ▶ play_again fired  |  pre-cleanup:", {
            gameState,
            score,
            noggles: noggles.length,
            things: things.length,
          });

          cleanupGame(() => {
            console.log("[DEBUG] ✔ cleanupGame callback  |  post-cleanup:", {
              gameState,
              score,
              noggles: noggles.length,
              things: things.length,
            });

            initializeGame();

            console.log("[DEBUG] ✔ initializeGame() done  |  after-init:", {
              gameState,
              score,
              noggles: noggles.length,
              things: things.length,
            });

            gameState = "playing";
            console.log("[DEBUG] ✱ gameState set → playing");

            // Add this line to restore focus to the canvas after reset
            document.querySelector("canvas").focus();
          });
        });

        window.FarcadeSDK.on("toggle_mute", ({ isMuted }) => {
          setMuted && setMuted(isMuted);
        });
      }

      function cleanupGame(cb) {
        console.log("[DEBUG] → cleanupGame START", {
          score,
          noggles: noggles.length,
          things: things.length,
        });

        // your existing teardown…
        noggles.length = 0;
        things.length = 0;
        platforms.length = 0;
        clouds.length = 0;

        // Reset particles for performance improvement
        particles = [];
        particles.push = function() { return particles.length; };

        score = 0;
        coyoteTimer = 0;
        jumpBufferTimer = 0;
        tagTimer = TAG_TIMER_MAX;

        // (clear any timeouts/intervals here)

        console.log("[DEBUG] ← cleanupGame END", {
          score,
          noggles: noggles.length,
          things: things.length,
        });

        if (typeof cb === "function") cb();
      }

      // — CONFIGURATION —
      const LEVEL_LENGTH = 100000;
      const MIN_PLAT_WIDTH = 150;
      const MAX_PLAT_WIDTH = 300;
      const MIN_GAP = 100;
      const MAX_GAP = 245;
      const DIFFICULTY_SCALE = 5;
      const PLAYER_MAX_JUMP_DIST = 330;
      const PLAYER_MAX_JUMP_HEIGHT = 190;
      const NOGGLE_MAX_DISTANCE = 300;
      const NOGGLE_MAX_SPEED = 20;
      const NOGGLE_GRAVITY = 0.45;

      // Define zones for platform introductions (as percentages of the total level length)
      const INTRO_ZONES = {
        normal: { start: 0, end: 0.01 }, // First 1% - only normal platforms
        bouncy: { start: 0.01, end: 0.05 }, // 1-5% - introduce bouncy
        moving: { start: 0.05, end: 0.1 }, // 5-10% - introduce moving
        crumbling: { start: 0.15, end: 0.2 }, // 15-20% - introduce crumbling (adjusted position)
        mixed: { start: 0.2, end: 1.0 }, // Final 80% - mix everything (expanded)
      };

      const boldBrightPalette = ["#F20422", "#FF1AD2", "#FFC110", "#1929F4", "#00FCFF"];
      
      const brightPalettes = {
        "Deep Fried": ["#B9185C", "#D22209", "#C16710", "#D08B11", "#FFE939"],
        "User Gnome": ["#FF1A0B", "#EC5B43", "#FFA21E", "#00A556", "#068940"],
        "Noun 1": ["#D26451", "#F78A18", "#FFC110", "#FF638D", "#CC0595"],
        "Bold & Bright": ["#F20422", "#FF1AD2", "#FFC110", "#1929F4", "#00FCFF"],
      };
      const dullPalettes = {
        "Cozy Cotton": ["#F9E8DD", "#F9F4E6", "#D7D3CD", "#CFC2AB", "#CBC1BC"],
      };

      const THING_BASE_SIZE = 120;
      const THING_BOB_AMPLITUDE = 10;
      const THING_BOB_SPEED = 0.05;

      // Tag-or-Die game mechanic
      const TAG_TIMER_MAX = 600; // 10 seconds at 60fps
      const TAG_TIMER_WARNING = 300; // 5 seconds warning threshold

      // sprite‑sheet setup
      const SPRITE_SHEET_URL =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/u0NamAsZmpLH/spritesheet_things_80-VYQyfGsuWRfn5VjS8uiyEkpRIo7PXu.png";
      const GREY_SPRITE_SHEET_URL =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/u0NamAsZmpLH/spritesheet_things_80_grey-EL90MwmI8yNVOFHmv7p0srC7YMfWfD.png";
      
        // Listen for messages from the character creator iframe
window.addEventListener('message', function(event) {
  // For local dev, you may skip origin check. For production, check event.origin!
  if (event.data && event.data.type === 'spriteUpdate') {
    loadImage(event.data.spritesheetDataUrl, (img) => {
      customPlayerSpriteSheet = img; // <--- store globally
      
      // Update the player object if it exists
      if (player) {
        player.spriteSheet = img;
      }
      
      // Handle custom noggles
      if (event.data.noggleDataUrl) {
        loadImage(event.data.noggleDataUrl, (nogImg) => {
          customPlayerNoggles = nogImg;
          noggleImg = nogImg; // Update immediately for current session
          console.log("Custom noggle image set!", nogImg, "Data URL:", event.data.noggleDataUrl);
        });
      }
      
      // Show confirmation message
      const confirmMsg = document.createElement('div');
      confirmMsg.textContent = "Character updated!";
      confirmMsg.style = "position:fixed; top:20px; left:50%; transform:translateX(-50%); background:#4CAF50; color:white; padding:10px; border-radius:5px; z-index:1000";
      document.body.appendChild(confirmMsg);
      setTimeout(() => {
        if (document.body.contains(confirmMsg)) {
          document.body.removeChild(confirmMsg);
        }
      }, 2000);
      
      // Hide the modal
      const modal = document.getElementById('characterCreatorModal');
      if (modal) {
        modal.style.display = 'none';
      }
      
      // Remove any loading indicators
      const loadingElement = document.getElementById('character-loading');
      if (loadingElement) {
        loadingElement.remove();
      }
    });
  }
});
      
        const THING_FRAME_SIZE = 64;
      const THING_FRAMES_PER_ROW = 20;
      const TOTAL_THING_ROWS = 4;
      const TOTAL_THING_FRAMES = THING_FRAMES_PER_ROW * TOTAL_THING_ROWS;

      // Particle system optimization
      const MAX_PARTICLES = 120; // Maximum particles allowed at once
      const PARTICLE_CULLING_DISTANCE = 1000; // Remove particles far from view

      // animation constants
      const FRAME_WIDTH = 48,
        FRAME_HEIGHT = 48;
      const ANIMATION_DEFS = {
        idle: { frames: 16, speed: 8 },
        walk: { frames: 8, speed: 6 },
        jump: { frames: 8, speed: 7 },
        fall: { frames: 8, speed: 7 },
      };
      const ANIMATION_MAP = {
        idle: { right: { row: 4, startFrame: 0 }, left: { row: 6, startFrame: 0 } },
        walk: { right: { row: 0, startFrame: 0 }, left: { row: 2, startFrame: 0 } },
        jump: { right: { row: 0, startFrame: 8 }, left: { row: 2, startFrame: 8 } },
        fall: { right: { row: 0, startFrame: 8 }, left: { row: 2, startFrame: 8 } },
      };

      // — STATE —
      let cloudImg,
        clouds = [];
      let joystick = { x: 0, y: 0, outer: 60, inner: 30, activeRadius: 150 };
      let jumpBtn = { x: 0, y: 0, r: 80 };
      let cameraX = 0,
        cameraY = 0,
        initialCameraY = 0;
      let noggles = [],
        things = [],
        score = 0;
      let particles = [];
      // Override the push method to do nothing, preventing particle creation for performance
      particles.push = function() { return particles.length; };
      let platforms = [],
        goal,
        levelWidth,
        gameState;
      let player, nounSpriteSheet, noggleImg, thingSpriteSheet, thingSpriteSheetGrey;
      let coyoteTimer = 0,
        jumpBufferTimer = 0,
        tagTimer = TAG_TIMER_MAX,
        previousJumpState = false; // Track jump button state for edge detection
      let customPlayerSpriteSheet = null;
      let customPlayerNoggles = null;

      // Debug mode variables
      let debugMode = false;
      let frameRateHistory = [];
      let frameRateUpdateTimer = 0;

      // Help system for platform types
      let helpTexts = {
        crumbling: { shown: false, text: "NEW! Crumbling platforms fall after you step on them!" },
        moving: { shown: false, text: "NEW! These blue platforms move left and right!" },
        bouncy: { shown: false, text: "NEW! Yellow platforms give you an extra boost!" },
      };

      // Track if each platform type has had a tutorial platform
      let tutorialShown = {
        crumbling: false,
        moving: false,
        bouncy: false,
      };

      let titleBg;
      // Track loading progress
      let loadingProgress = 0;
      let totalAssets = 6; // Total number of assets to load (including greyscale sprite sheet)
      let assetsLoaded = 0;

      // Function to update the loading progress UI
      function updateLoadingProgress(increment = 1) {
        assetsLoaded += increment;
        loadingProgress = (assetsLoaded / totalAssets) * 100;

        // Update the loading bar
        const progressBar = document.getElementById("loading-progress-bar");
        const loadingText = document.getElementById("loading-text");

        if (progressBar) {
          progressBar.style.width = loadingProgress + "%";
        }

        if (loadingText) {
          if (loadingProgress < 100) {
            loadingText.textContent = `Loading game assets... ${Math.floor(loadingProgress)}%`;
          } else {
            loadingText.textContent = "Ready to play!";
          }
        }
      }

      function preload() {
        // Start by showing zero progress
        updateLoadingProgress(0);

        // Load each asset with a callback to update progress
        nounSpriteSheet = loadImage(
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/u0NamAsZmpLH/myNounsSpritesheet_003-ymLtEkBrlNZMQkj37npozrPDdamMbF.png",
          () => updateLoadingProgress(),
        );

        noggleImg = loadImage(
  "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/u0NamAsZmpLH/glasses-square-red-ge40H7EEizX6BtKLM99M270Y9htR9s.png",
  () => updateLoadingProgress(),
);

        cloudImg = loadImage(
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/u0NamAsZmpLH/head-cloud-i9zXsgKYOqRd5S0VjKaziZYVDtZbmf.png",
          () => updateLoadingProgress(),
        );

        thingSpriteSheet = loadImage(SPRITE_SHEET_URL, () => updateLoadingProgress());
        thingSpriteSheetGrey = loadImage(GREY_SPRITE_SHEET_URL, () => updateLoadingProgress());

        titleBg = loadImage(
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/u0NamAsZmpLH/nounifyTheWorldTitle_1-0Wbv9O9w8f1mM12NI9CssOfFIRXlKt.png",
          () => updateLoadingProgress(),
        );
      }

      function setup() {
        pixelDensity(window.devicePixelRatio || 1);
        let cnv = createCanvas(500, 800).parent("game-container");
        cnv.elt.removeAttribute("style");

        // Add this line to make the canvas focusable
        cnv.elt.setAttribute("tabindex", "0");

        // Initially focus the canvas to ensure keyboard input works from the start
        cnv.elt.focus();

        // Handle canvas click events to ensure focus is regained
        cnv.elt.addEventListener("click", function () {
          cnv.elt.focus();
        });

        // Add event for window focus to prevent stuck keys
        window.addEventListener("focus", function () {
          // Reset any potentially stuck keys by using the keyTracker
          document.querySelector("canvas").focus();
        });

        // Make sure loading screen is properly hidden
        const loadingScreen = document.getElementById("p5_loading");
        if (loadingScreen) {
          // Add a "loaded" class for smooth transition
          loadingScreen.classList.add("loaded");

          // Then remove the element after transition completes
          setTimeout(() => {
            loadingScreen.style.display = "none";
          }, 500);
        }

        noSmooth();
        textAlign(CENTER, CENTER);
        imageMode(CENTER);
        colorMode(RGB, 255);

        initializeGame();
        // Position the player lower on the screen (show more ahead)
        initialCameraY = player.y - height * 0.7; // Changed from height/2
        cameraY = initialCameraY;
        joystick.x = 80;
        joystick.y = height - 80;
        jumpBtn.x = width - 80;
        jumpBtn.y = height - 80;

        if (window.FarcadeSDK?.singlePlayer) {
          window.FarcadeSDK.singlePlayer.actions.ready();
        }
      }

      function initializeGame() {
        console.log("[DEBUG] → initializeGame START");
        randomSeed(millis());
        const dullKeys = Object.keys(dullPalettes),
          brightKeys = Object.keys(brightPalettes);
        activeDullPalette = dullPalettes[dullKeys[floor(random(dullKeys.length))]];
        activeBrightPalette = brightPalettes[brightKeys[floor(random(brightKeys.length))]];

        noggles = [];
        // Reset the particles array and restore its push method for performance improvement
        particles = [];
        particles.push = function() { return particles.length; };
        score = 0;
        coyoteTimer = 0;
        jumpBufferTimer = 0;
        tagTimer = TAG_TIMER_MAX;
        previousJumpState = false;

        player = {
          x: 100,
          y: height - 100,
          width: FRAME_WIDTH,
          height: FRAME_HEIGHT,
          velocityX: 0,
          velocityY: 0,
          isOnGround: false,
          wasOnGround: false,
          jumpSquash: 0,
          throwSquash: 0,
          spriteSheet: customPlayerSpriteSheet ? customPlayerSpriteSheet : nounSpriteSheet,
          animation: { currentSet: "idle", facingDirection: 1, frameIndex: 0, tick: 0 },
          platformBelow: null, // Add tracking for the current platform the player is on
        };

        // Reset the target camera position but don't immediately set the actual camera position
        // This allows the camera to smoothly travel back to the start
        // Position the player at about 2/3 down the screen instead of center
        initialCameraY = player.y - height * 0.7; // Changed from height/2 to height*0.7

        // Don't immediately reset camera position, let it lerp in updateCamera()
        // cameraY = initialCameraY;
        // cameraX = 0;

        platforms = [
          {
            x: 0,
            y: height - 50,
            w: 400,
            h: 50,
            color: activeDullPalette[floor(random(activeDullPalette.length))],
            type: "normal",
          },
        ];

        let xPos = 400,
          prevY = height - 50,
          chunkIdx = 0;
        while (xPos < LEVEL_LENGTH) {
          let d = min(chunkIdx / DIFFICULTY_SCALE, 1),
            gap = lerp(MIN_GAP, MAX_GAP, d);
          xPos += random(gap * 0.8, gap * 1.2);
          let platW = random(MIN_PLAT_WIDTH, lerp(MAX_PLAT_WIDTH, MIN_PLAT_WIDTH, d)),
            vertRange = lerp(PLAYER_MAX_JUMP_HEIGHT * 0.5, PLAYER_MAX_JUMP_HEIGHT, d),
            newY = constrain(prevY + random(-vertRange, vertRange), 100, height - 150);
          // Determine platform type using distance-based progression
          let platformType = "normal";
          let platformIsTutorial = false;

          // Calculate current level progress as percentage of total level length
          const levelProgress = xPos / LEVEL_LENGTH;

          // Determine available platform types based on current level progress
          const availableTypes = ["normal"]; // Always include normal platforms
          if (levelProgress >= INTRO_ZONES.bouncy.start) availableTypes.push("bouncy");
          if (levelProgress >= INTRO_ZONES.moving.start) availableTypes.push("moving");
          if (levelProgress >= INTRO_ZONES.crumbling.start) availableTypes.push("crumbling");

          // Each zone specifically introduces and features one platform type
          if (levelProgress < INTRO_ZONES.bouncy.start) {
            // Beginning area: Always normal platforms
            platformType = "normal";
          } else if (levelProgress < INTRO_ZONES.moving.start) {
            // Bouncy introduction zone (first 10%-25%)
            const zoneProgress =
              (levelProgress - INTRO_ZONES.bouncy.start) / (INTRO_ZONES.bouncy.end - INTRO_ZONES.bouncy.start);

            // Higher chance of bouncy platforms as player progresses through zone
            const bouncyChance = 0.3 + zoneProgress * 0.2; // 30% to 50% chance

            // Choose platform type with weighted probability
            platformType = random() < bouncyChance ? "bouncy" : "normal";

            // Force tutorial platform at the beginning of the bouncy zone
            if (!tutorialShown.bouncy && levelProgress < INTRO_ZONES.bouncy.start + 0.02) {
              platformType = "bouncy";
              tutorialShown.bouncy = true;
              platformIsTutorial = true;
            }
          } else if (levelProgress < INTRO_ZONES.crumbling.start) {
            // Moving platforms zone (5%-15%)
            const typeRoll = random();

            if (typeRoll < 0.4) {
              platformType = "moving";
            } else if (typeRoll < 0.6) {
              platformType = "bouncy";
            } else {
              platformType = "normal";
            }

            // Force tutorial platform at the beginning of the moving zone
            if (!tutorialShown.moving && levelProgress < INTRO_ZONES.moving.start + 0.02) {
              platformType = "moving";
              tutorialShown.moving = true;
              platformIsTutorial = true;
            }
          } else if (levelProgress < INTRO_ZONES.mixed.start) {
            // Crumbling platforms zone (15%-20%)
            const typeRoll = random();

            if (typeRoll < 0.3) {
              platformType = "crumbling";
            } else if (typeRoll < 0.5) {
              platformType = "moving";
            } else if (typeRoll < 0.75) {
              platformType = "bouncy";
            } else {
              platformType = "normal";
            }

            // Force tutorial platform at the beginning of the crumbling zone
            if (!tutorialShown.crumbling && levelProgress < INTRO_ZONES.crumbling.start + 0.02) {
              platformType = "crumbling";
              tutorialShown.crumbling = true;
              platformIsTutorial = true;
            }
          } else {
            // Final mixed zone (90%-100%): balanced mix of all platform types
            // Use a more sophisticated distribution with increasing difficulty
            const finalZoneProgress =
              (levelProgress - INTRO_ZONES.mixed.start) / (INTRO_ZONES.mixed.end - INTRO_ZONES.mixed.start);

            // Gradually decrease normal platforms, increase special platforms
            const normalChance = 0.3 - finalZoneProgress * 0.2; // 30% down to 10%
            const typeRoll = random();

            if (typeRoll < normalChance) {
              platformType = "normal";
            } else {
              // Select randomly from all special platform types
              const specialTypes = ["bouncy", "moving", "crumbling"];
              platformType = specialTypes[Math.floor(random() * specialTypes.length)];
            }

            // In the final zone, occasionally create challenging platform sequences
            if (platforms.length > 0 && random() < 0.4) {
              const prevPlatform = platforms[platforms.length - 1];
              if (prevPlatform.type !== "normal") {
                // 40% chance to repeat the previous platform type for increased challenge
                platformType = prevPlatform.type;
              }
            }
          }

          // Calculate zone-based difficulty scaling factors (0-1 range)
          const zoneProgress = levelProgress / INTRO_ZONES.mixed.start; // 0-1 over the course of the main zones
          const difficultyFactor = min(zoneProgress * 1.2, 1); // Cap at 1.0, but ramp up slightly faster

          // Create the platform with type-specific properties
          let platform = {
            x: xPos,
            y: newY,
            w: platW,
            h: 20,
            color: activeDullPalette[floor(random(activeDullPalette.length))],
            type: platformType,
            isTutorial: platformIsTutorial,
            zoneDifficulty: zoneProgress, // Store the zone difficulty for visual indicators
          };

          // Add type-specific properties that scale with zone progression
          switch (platformType) {
            case "crumbling":
              // Make platforms crumble faster as game progresses
              const baseMax = platformIsTutorial ? 240 : 60; // Tutorial platforms last a bit longer
              const minMax = 60; // Minimum frames before collapse at max difficulty
              platform.crumbleTimer = -1; // -1 means not triggered yet
              platform.crumbleMax = round(lerp(baseMax, minMax, difficultyFactor));
              platform.originalColor = platform.color;

              // Set special color for tutorial platform
              if (platformIsTutorial) {
                platform.color = color(220, 170, 120); // More distinctive color
              }
              break;

            // Vertical platform type has been removed

            case "moving":
              platform.startX = xPos;
              platform.startY = newY;
              // Initialize prevX to current position to avoid first frame jumps
              platform.prevX = xPos;

              if (platformIsTutorial) {
                // Tutorial moving platforms move slower and less distance
                platform.amplitude = 70;
                platform.speed = 0.015;
              } else {
                // Increase movement range and speed as game progresses
                const baseAmplitude = 50;
                const maxAmplitude = 150;
                platform.amplitude = lerp(baseAmplitude, maxAmplitude, difficultyFactor);

                const baseSpeed = 0.01;
                const maxSpeed = 0.04;
                platform.speed = lerp(baseSpeed, maxSpeed, difficultyFactor);

                // All moving platforms use the standard blue color
                platform.color = color(80, 180, 255); // Standard blue
              }

              platform.phase = random(TWO_PI);

              // Set special color for tutorial platform
              if (platformIsTutorial) {
                platform.color = color(100, 200, 255); // Brighter blue for tutorial
              }
              break;

            case "bouncy":
              if (platformIsTutorial) {
                // Tutorial bouncy platforms are more predictable
                platform.bounceFactor = 1.3; // Consistent 30% boost
              } else {
                // Increase bounce height as game progresses
                const baseBounce = 1.2; // 20% boost at start
                const maxBounce = 1.5; // 50% boost at end
                platform.bounceFactor = lerp(baseBounce, maxBounce, difficultyFactor);
              }

              platform.springCompression = 0;

              // Use a more springy color (yellowish), brighter for tutorial
              platform.color = platformIsTutorial
                ? color(255, 255, 80) // Bright yellow for tutorial
                : color(255, 240, 80); // Standard yellow
              break;

            case "normal":
              // Even normal platforms get some visual treatment if they're tutorial platforms
              if (platformIsTutorial) {
                platform.color = color(220, 220, 220); // Brighter
              }
              break;
          }

          platforms.push(platform);
          prevY = newY;
          xPos += platW;
          chunkIdx++;
        }
        levelWidth = xPos + 500;

        goal = {
          x: levelWidth - 200,
          y: random(height / 2, height - 200),
          w: 50,
          h: 50,
          color: activeBrightPalette[floor(random(activeBrightPalette.length))],
        };

        // Get player's current viewport for determining thing positions
        const playerViewportTop = player.y - height / 2;

        things = platforms
          .filter((_, i) => i % 3 === 0)
          .map((p) => {
            // compute spawn x position randomly on the platform
            const tx = random(p.x + 10, p.x + p.w - 10);

            // Always position things relative to player viewport (60-200px above player's head)
            const minY = playerViewportTop + 60;
            const maxY = playerViewportTop + 200;
            const ty = random(minY, maxY);

            // pick a random frame index
            const idx = floor(random(TOTAL_THING_FRAMES));

            return {
              x: tx,
              y: ty,
              size: THING_BASE_SIZE,
              phase: random(TWO_PI),
              frameIndex: idx,
              collected: false,
            };
          });

        clouds = Array.from({ length: 20 }, () => ({
          x: random(0, levelWidth),
          y: random(50, height / 2),
          size: random(0.5, 1.5),
          speedFactor: random(0.2, 0.5),
        }));

        gameState = "start";
        console.log("[DEBUG] ← initializeGame END", {
          score,
          noggles: noggles.length,
          things: things.length,
          platforms: platforms.length,
          clouds: clouds.length,
        });

        // Ensure canvas gets focus to capture keyboard events
        setTimeout(() => {
          document.querySelector("canvas").focus();
        }, 100);
      }

      // New styles for Bold & Bright theme
      const STYLE = {
        colors: {
          // Bold & Bright palette
          red: "#F20422",
          pink: "#FF1AD2", 
          yellow: "#FFC110",
          blue: "#1929F4",
          cyan: "#00FCFF",
          // Additional colors for background elements
          sky: "#63A0F9",
          outlineColor: "#000000",
          windowColor: "#FFFFFF",
          roadColor: "#333333",
          sidewalkColor: "#CCCCCC"
        },
        buildings: {
          outlineWeight: 3,
          minWidth: 60,
          maxWidth: 150,
          minHeight: 100,
          maxHeight: 350,
          windowSize: 10,
          windowGap: 5
        }
      };
      
      // Building cache for rendering efficiency
      let backgroundBuildings = [];
      let foregroundBuildings = [];
      let cityBackground = null;
      
      // Generate buildings for the city background
      function generateCityBackground() {
        // Clear existing building arrays
        backgroundBuildings = [];
        foregroundBuildings = [];
        
        // Generate background buildings
        let x = 0;
        while (x < LEVEL_LENGTH) {
          const w = random(STYLE.buildings.minWidth, STYLE.buildings.maxWidth);
          const h = random(STYLE.buildings.minHeight, STYLE.buildings.maxHeight);
          const y = height - h;
          const type = floor(random(3)); // 0=bg, 1=fg, 2=special
          
          // Assign color based on Bold & Bright palette
          const colors = [STYLE.colors.red, STYLE.colors.pink, STYLE.colors.yellow, 
                          STYLE.colors.blue, STYLE.colors.cyan];
          const color = colors[floor(random(colors.length))];
          
          const building = {
    x, y, w, h, color, type,
    windowRows: floor(h / (STYLE.buildings.windowSize + STYLE.buildings.windowGap)),
    windowCols: floor(w / (STYLE.buildings.windowSize + STYLE.buildings.windowGap)),
    hasAntenna: random() > 0.7,
  antennaHeight: random(20, 50), // Store the height permanently
    hasSign: random() > 0.8,
    // Add this new property - a 2D array of window visibility
    windows: []
  };
  
  // Generate window visibility pattern when the building is created
  for (let r = 0; r < building.windowRows; r++) {
    building.windows[r] = [];
    for (let c = 0; c < building.windowCols; c++) {
      // Store whether this window should be visible (true/false)
      building.windows[r][c] = random() > 0.3;
    }
  }
          
          if (type === 0) {
            backgroundBuildings.push(building);
          } else {
            foregroundBuildings.push(building);
          }
          
          x += w - random(w/4); // Slight overlap for density
        }
        
        // Sort buildings by height for layered rendering
        backgroundBuildings.sort((a, b) => a.h - b.h);
      }
      
      // Draw a single building with the Bold & Bright style
      function drawBuilding(building, outline = true) {
        const {x, y, w, h, color, windowRows, windowCols} = building;
        
        // Draw main building shape
        fill(color);
        if (outline) {
          strokeWeight(STYLE.buildings.outlineWeight);
          stroke(STYLE.colors.outlineColor);
        } else {
          noStroke();
        }
        rect(x, y, w, h, 2); // Slightly rounded corners
        
        // Draw windows using the pre-computed visibility
  fill(STYLE.colors.windowColor);
  noStroke();
  const windowSize = STYLE.buildings.windowSize;
  const gap = STYLE.buildings.windowGap;
  
  for (let r = 0; r < windowRows; r++) {
    for (let c = 0; c < windowCols; c++) {
      // Use the stored visibility instead of calling random() each time
      if (building.windows[r][c]) {
        const wx = x + gap + c * (windowSize + gap);
        const wy = y + gap + r * (windowSize + gap);
        rect(wx, wy, windowSize, windowSize);
      }
    }
  }
        
        // Draw antenna or sign if applicable
        if (building.hasAntenna) {
          strokeWeight(STYLE.buildings.outlineWeight);
          stroke(STYLE.colors.outlineColor);
          line(x + w/2, y, x + w/2, y - building.antennaHeight); // Use stored height
        }
        
        if (building.hasSign) {
          fill(STYLE.colors.yellow);
          stroke(STYLE.colors.outlineColor);
          rect(x + w/4, y, w/2, 20, 2);
        }
      }
      
      // Draw a stylized cloud
      function drawStylizedCloud(x, y, size) {
        push();
        noStroke();
        fill(255);
        ellipseMode(CENTER);
        
        // Draw cloud body
        ellipse(x, y, size, size * 0.6);
        ellipse(x - size * 0.4, y, size * 0.6, size * 0.4);
        ellipse(x + size * 0.4, y, size * 0.6, size * 0.4);
        
        // Draw outline
        stroke(0);
        strokeWeight(2);
        noFill();
        beginShape();
        vertex(x - size * 0.7, y);
        bezierVertex(x - size * 0.7, y - size * 0.3, 
                     x - size * 0.3, y - size * 0.4, 
                     x, y - size * 0.3);
        bezierVertex(x + size * 0.3, y - size * 0.4, 
                     x + size * 0.7, y - size * 0.3, 
                     x + size * 0.7, y);
        bezierVertex(x + size * 0.7, y + size * 0.3, 
                     x + size * 0.3, y + size * 0.3, 
                     x, y + size * 0.3);
        bezierVertex(x - size * 0.3, y + size * 0.3, 
                     x - size * 0.7, y + size * 0.3, 
                     x - size * 0.7, y);
        endShape();
        pop();
      }
      
      // Draw a procedural city background
      function drawCityBackground() {
        // If we haven't generated buildings yet, do so
        if (backgroundBuildings.length === 0 && foregroundBuildings.length === 0) {
          generateCityBackground();
        }
        
        // Draw sky
        background(STYLE.colors.sky);
        
        // Draw distant background buildings
        for (const building of backgroundBuildings) {
          const relX = building.x - cameraX * 0.3; // Parallax effect
          if (relX + building.w < 0 || relX > width) continue; // Skip if off-screen
          push();
          // Make background buildings darker/desaturated
          fill(lerpColor(color(building.color), color(30, 30, 50), 0.5));
          noStroke();
          rect(relX, building.y, building.w, building.h);
          pop();
        }
        
        // Draw stylized clouds instead of using images
        for (const c of clouds) {
          const sx = c.x - cameraX * c.speedFactor;
          if (sx + 100 < 0 || sx > width + 100) continue; // Skip if off-screen
          drawStylizedCloud(sx, c.y, 40 * c.size);
        }
        
        // Draw foreground buildings
        for (const building of foregroundBuildings) {
          const relX = building.x - cameraX * 0.8; // Less parallax for foreground
          if (relX + building.w < 0 || relX > width) continue; // Skip if off-screen
          push();
          translate(relX - building.x, 0); // Transform to building position
          drawBuilding(building);
          pop();
        }
        
      }

      function draw() {
        // ── log whenever gameState changes ──
        if (gameState !== _prevState) {
          console.log(`[DEBUG] STATE: ${_prevState} → ${gameState}`);
          _prevState = gameState;
        }
        drawCityBackground();
        // drawClouds(); // Replaced by our procedural cloud drawing

        if (gameState === "start") {
          displayStartScreen();
        } else if (gameState === "playing") {
          runGame();
          drawUI();
        } else {
          // either "gameOver" or "win"
          drawGameScene();
          if (window.FarcadeSDK?.singlePlayer) {
            window.FarcadeSDK.singlePlayer.actions.gameOver({ score });
          }
        }

        // Draw debug info if debug mode is enabled
        if (debugMode) {
          drawDebugInfo();
        }
      }

      // Function to draw debug information
      function drawDebugInfo() {
        // Calculate frame rate every 10 frames
        frameRateUpdateTimer++;
        if (frameRateUpdateTimer >= 10) {
          frameRateUpdateTimer = 0;
          frameRateHistory.push(frameRate());
          if (frameRateHistory.length > 10) {
            frameRateHistory.shift();
          }
        }

        // Calculate average FPS over the history
        const avgFps =
          frameRateHistory.length > 0
            ? frameRateHistory.reduce((a, b) => a + b, 0) / frameRateHistory.length
            : frameRate();

        // Check if low performance mode is active
        const lowPerformanceMode = avgFps < 40;

        // Setup for debug text
        push();
        fill(0, 0, 0, 180);
        rect(10, 10, 200, 170); // Made taller for additional info

        // FPS display color based on performance
        if (lowPerformanceMode) {
          fill(255, 100, 100); // Red for low performance
        } else {
          fill(100, 255, 100); // Green for good performance
        }

        textAlign(LEFT, TOP);
        textSize(14);

        // Display FPS
        text(`FPS: ${avgFps.toFixed(1)}`, 20, 20);

        // Performance mode indicator
        if (lowPerformanceMode) {
          text("LOW PERFORMANCE MODE ACTIVE", 20, 40);
        } else {
          text("Performance: GOOD", 20, 40);
        }

        fill(255, 255, 0); // Yellow for other debug info

        // Display current position in level
        const levelProgress = player.x / LEVEL_LENGTH;
        text(`Level progress: ${(levelProgress * 100).toFixed(2)}%`, 20, 60);

        // Display current zone
        let currentZone = "Normal";
        if (levelProgress >= INTRO_ZONES.crumbling.start) currentZone = "Crumbling";
        else if (levelProgress >= INTRO_ZONES.moving.start) currentZone = "Moving";
        else if (levelProgress >= INTRO_ZONES.bouncy.start) currentZone = "Bouncy";
        text(`Current zone: ${currentZone}`, 20, 80);

        // Player position
        text(`Player pos: ${Math.round(player.x)}, ${Math.round(player.y)}`, 20, 100);

        // Controls help
        text("Debug Controls:", 20, 120);
        text("D: Toggle debug mode", 20, 140);
        text("1-5: Teleport to zones", 20, 160);

        pop();

        // Draw zone boundaries as vertical lines on screen
        push();
        translate(-cameraX, -cameraY);
        strokeWeight(3);
        stroke(255, 255, 0, 100);

        // Draw line for each zone boundary
        for (const zone in INTRO_ZONES) {
          if (INTRO_ZONES[zone].start > 0) {
            const boundaryX = LEVEL_LENGTH * INTRO_ZONES[zone].start;
            line(boundaryX, cameraY, boundaryX, cameraY + height);

            // Add zone label
            fill(255, 255, 0);
            noStroke();
            textSize(16);
            text(zone, boundaryX + 10, cameraY + 50);
          }
        }
        pop();
      }

      function runGame() {
        // Collect all inputs first
        const inputs = collectInputs();

        // Process jump buffer and coyote time
        updateJumpState();

        // Apply movement physics based on inputs
        applyMovementPhysics(inputs);

        // Handle other player input (jumping, throwing)
        // handlePlayerInput(inputs);

        // Regular physics and collision updates
        updatePlayer();
        updatePlayerAnimationState();
        advancePlayerFrame();

        // Camera and visual updates after physics
        updateCamera();
        updateTagTimer();
        drawGameScene();
        updateNoggles();

        // Win/loss conditions
        checkGoal();
        checkFallen();
      }

      function updateTagTimer() {
        tagTimer--;
        if (tagTimer <= 0) {
          console.log("[DEBUG] tagTimer expired → gameOver", {
            score,
            gameStateBefore: gameState,
          });
          gameState = "gameOver";
        }
      }

      function updateCamera() {
        // Show more horizontal space by moving camera more gently
        const tx = player.x - width * 0.35;
        cameraX = constrain(lerp(cameraX, tx, 0.05), 0, max(levelWidth - width, 0)); // Reduced from 0.1 to 0.05

        // Use more relaxed vertical thresholds to reduce camera movement
        const lookDownThreshold = height * 0.6; // Increased from 0.55 to 0.6
        const lookUpThreshold = height * 0.3; // Decreased from 0.35 to 0.3

        // Calculate the player's position on screen
        const playerScreenY = player.y - cameraY;

        // Determine target camera Y position with more relaxed rules
        let targetY = cameraY; // Default to keeping current position

        // Only move camera if player is significantly outside comfort zone
        if (playerScreenY > lookDownThreshold && player.velocityY > 2) {
          // Only look down when falling with some velocity and well below threshold
          targetY = player.y - lookDownThreshold + player.velocityY * 1.5; // Reduced from 3 to 1.5
        }
        // Only move camera up if player is significantly above the threshold
        else if (playerScreenY < lookUpThreshold) {
          targetY = player.y - lookUpThreshold;
        }

        // Apply much slower vertical camera movement
        const verticalLerpFactor = player.velocityY > 5 ? 0.04 : 0.01; // Reduced from 0.08/0.02 to 0.04/0.01

        // Add a deadzone where camera doesn't move at all for small changes
        if (Math.abs(targetY - cameraY) > 5) {
          cameraY = lerp(cameraY, targetY, verticalLerpFactor);
        }

        // Add damping to smooth out any jerkiness
        player.lastCameraY = player.lastCameraY || cameraY;
        const cameraDelta = cameraY - player.lastCameraY;

        // If camera is moving too quickly, apply additional damping
        if (Math.abs(cameraDelta) > 10) {
          cameraY = player.lastCameraY + cameraDelta * 0.7; // Dampen sudden large movements
        }

        player.lastCameraY = cameraY;

        // Keep the camera from going higher than the initial position
        cameraY = min(cameraY, initialCameraY);
      }

      function updateAndDrawParticles() {
        // Performance improvement: All particles and effects have been removed
        // Function now returns immediately without doing any work
        return;
      }

      function drawGameScene() {
        push();
        translate(-cameraX, -cameraY);
        drawPlatforms();
        drawThings();
        drawGoal();
        drawPlayer();
        drawNoggles();
        pop();

        // Draw particles after everything else
        updateAndDrawParticles();

        // Draw tag timer effects after everything else
        if (gameState === "playing") {
          drawTagCountdown();
        }
      }

      // New function to draw the tag countdown visuals
      function drawTagCountdown() {
        if (tagTimer <= TAG_TIMER_WARNING) {
          // Calculate desaturation intensity that grows as timer decreases
          const desaturationIntensity = customMap(tagTimer, TAG_TIMER_WARNING, 0, 0, 1);
          drawDesaturationEffect(desaturationIntensity);

          // Draw countdown timer for last 5 seconds
          const seconds = ceil(tagTimer / 60);
          if (seconds <= 5) {
            textAlign(CENTER, CENTER);
            textSize(64);
            // Make it flash when under 3 seconds
            if (seconds > 2 || frameCount % 10 < 5) {
              fill(255, 0, 0, 200);
              text(seconds, width / 2, height / 3);
            }
          }
        }

        // Tag timer display has been removed for a cleaner UI
      }

      // Function to draw desaturation effect for countdown
      function drawDesaturationEffect(intensity) {
        if (intensity <= 0) return;

        // Get current performance level
        const currentFPS = frameRate();
        const lowPerformanceMode = currentFPS < 30;

        // Calculate dimensions for gradients (these were missing!)
        const minDim = min(width, height);
        const maxDim = max(width, height);

        push();
        noStroke();
        
        // Use simplified effect when performance is low
        if (lowPerformanceMode) {
          // Simple white overlay with transparency for desaturation
          fill(255, 255, 255, intensity * 120);
          rect(0, 0, width, height);
          
          // Add a slight blue tint to make it feel colder
          fill(200, 220, 255, intensity * 40);
          rect(0, 0, width, height);
          
          pop();
          return;
        }
        
        // Draw a semi-transparent white overlay to desaturate
        drawingContext.save();
        
        // Create a uniform desaturation effect
        const desatAmount = intensity * 0.7;
        fill(255, 255, 255, desatAmount * 150);
        rect(0, 0, width, height);
        
        // Add a subtle blue-gray tint to make it feel washed out
        fill(210, 220, 240, desatAmount * 80);
        rect(0, 0, width, height);
        
        drawingContext.restore();

        // Add subtle gradient effect for more emphasis at the edges
        if (intensity > 0.3) {
          drawingContext.save();
          
          // Create a radial gradient that's stronger at the edges
          const gradient = drawingContext.createRadialGradient(
            width / 2,
            height / 2,
            minDim * 0.1,
            width / 2,
            height / 2,
            maxDim * 0.7,
          );

          const edgeIntensity = intensity * 0.9;
          gradient.addColorStop(0, "rgba(255, 255, 255, 0)");
          gradient.addColorStop(0.6, "rgba(255, 255, 255, " + edgeIntensity * 0.2 + ")");
          gradient.addColorStop(1, "rgba(240, 248, 255, " + edgeIntensity * 0.5 + ")"); // Slight blue tint at edges

          drawingContext.fillStyle = gradient;
          drawingContext.globalAlpha = intensity;
          drawingContext.fillRect(0, 0, width, height);
          drawingContext.restore();
          
          // Add slight red warning tint for urgency when timer is critical
          if (intensity > 0.7) {
            drawingContext.save();
            drawingContext.globalAlpha = customMap(intensity, 0.7, 1, 0, 0.15);
            drawingContext.fillStyle = "rgba(255, 0, 0, 0.15)";
            drawingContext.fillRect(0, 0, width, height);
            drawingContext.restore();
          }
        }
        
        pop();
      }

      function drawClouds() {
        imageMode(CENTER);
        noTint();
        clouds.forEach((c) => {
          const sx = c.x - cameraX * c.speedFactor;
          image(cloudImg, sx, c.y, cloudImg.width * c.size, cloudImg.height * c.size);
        });
      }

      function drawPlatforms() {
        // Update crumbling platforms first
        for (let i = platforms.length - 1; i >= 0; i--) {
          const p = platforms[i];
          if (p.type === "crumbling" && p.crumbleTimer > 0) {
            p.crumbleTimer--;

            // Create falling debris when timer expires
            if (p.crumbleTimer === 0) {
              // Generate a text effect for crash
              particles.push({
                x: p.x + p.w / 2,
                y: p.y,
                vx: 0,
                vy: -2,
                color: color(255, 100, 50),
                size: 2,
                life: 50,
                maxLife: 50,
                type: "text",
                text: "CRASH!",
                textSize: 18,
              });

              // Remove the platform
              platforms.splice(i, 1);
              continue;
            }
          }
        }

        // Draw all platforms with new Bold & Bright style
        rectMode(CORNER);
        platforms.forEach((p) => {
          // Skip off-screen platforms for performance
          if (p.x + p.w < cameraX || p.x > cameraX + width) {
            return;
          }
          
          // Common platform properties
          const isTutorial = p.isTutorial === true;
          
          // Calculate platform color based on type
          let platformColor;
          let outlineColor = "#000000";
          let outlineWeight = 3;
          
          // Map platform types to Bold & Bright colors
          switch (p.type) {
            case "normal":
              platformColor = STYLE.colors.cyan; // Cyan for normal platforms
              break;
            case "bouncy":
              platformColor = STYLE.colors.yellow; // Yellow for bouncy platforms
              break;
            case "moving":
              platformColor = STYLE.colors.blue; // Blue for moving platforms
              break;
            case "crumbling":
              // Calculate how "broken" the platform is (0-1) for crumbling platforms
              if (p.crumbleTimer > 0) {
                const brokenness = 1 - p.crumbleTimer / p.crumbleMax;
                platformColor = lerpColor(color(STYLE.colors.red), color("#8B4513"), brokenness);
              } else {
                platformColor = STYLE.colors.red; // Red for crumbling platforms
              }
              break;
            default:
              platformColor = STYLE.colors.cyan; // Default
          }
          
          // Draw platform with pixel art style
          push();
          
          // Add pulsing effect for tutorial platforms
          if (isTutorial) {
            const pulseAmount = sin(frameCount * 0.1) * 0.5 + 0.5; // 0-1 oscillation
            outlineWeight = 4 + pulseAmount * 2;
            
            // Add "NEW!" indicator text above tutorial platforms
            if (frameCount % 90 < 60) {
              fill("#FFC110");
              stroke("#000000");
              strokeWeight(3);
              textSize(16);
              textStyle(BOLD);
              text("NEW!", p.x + p.w / 2, p.y - 25);
              textStyle(NORMAL);
            }
          }
          
          // Calculate horizontal position for moving platforms
          if (p.type === "moving") {
            // Store previous position before updating
            if (p.prevX === undefined) {
              p.prevX = p.x;
            } else {
              p.prevX = p.x;
            }
            
            // Calculate position based on sine wave
            const horizOffset = sin(frameCount * p.speed + p.phase) * p.amplitude;
            p.x = p.startX + horizOffset;
            
            // Draw direction arrow on moving platforms
            const arrowDir = (horizOffset > 0) ? -1 : 1;
            if (abs(horizOffset) > p.amplitude * 0.8) {
              stroke(0);
              strokeWeight(2);
              fill(255);
              const arrowX = p.x + (arrowDir < 0 ? p.w - 15 : 15);
              const arrowSize = 8;
              triangle(
                arrowX, p.y + p.h/2,
                arrowX + arrowDir * arrowSize, p.y + p.h/2 - arrowSize,
                arrowX + arrowDir * arrowSize, p.y + p.h/2 + arrowSize
              );
            }
          }
          
          // Create pixel-art style platform with bold outline
          fill(platformColor);
          strokeWeight(outlineWeight);
          stroke(outlineColor);
          
          // Draw platform base with rounded corners
          rect(p.x, p.y, p.w, p.h, 3);
          
          // Add special visual effects based on platform type
          if (p.type === "bouncy") {
            // Draw spring pattern for bouncy platforms
            noStroke();
            fill(255, 255, 255, 100);
            
            const patternCount = floor(p.w / 20);
            const patternWidth = p.w / patternCount;
            
            for (let i = 0; i < patternCount; i++) {
              if (i % 2 === 0) {
                const px = p.x + i * patternWidth;
                const zigzagHeight = 8;
                
                // Spring zigzag pattern
                fill(255, 255, 255, 80);
                beginShape();
                vertex(px, p.y + p.h - 3);
                vertex(px + patternWidth/4, p.y + p.h - zigzagHeight);
                vertex(px + patternWidth/2, p.y + p.h - 3);
                vertex(px + patternWidth*3/4, p.y + p.h - zigzagHeight);
                vertex(px + patternWidth, p.y + p.h - 3);
                endShape();
              }
            }
            
            // Bounce compression indicator
            if (p.springCompression > 0) {
              const compressionLine = p.springCompression * 3;
              stroke(255, 255, 255, 150);
              strokeWeight(2);
              line(p.x + 5, p.y + compressionLine, p.x + p.w - 5, p.y + compressionLine);
            }
            
            // Spring gradually decompresses
            p.springCompression = max(0, p.springCompression - 0.5);
            
          } else if (p.type === "crumbling" && p.crumbleTimer > 0) {
            // Draw cracks for crumbling platforms
            stroke(0);
            strokeWeight(1);
            
            const brokenness = 1 - p.crumbleTimer / p.crumbleMax;
            const crackCount = floor(10 * brokenness);
            
            // Draw pixel-style cracks
            for (let i = 0; i < crackCount; i++) {
              const x1 = p.x + random(p.w);
              const y1 = p.y + random(p.h);
              const len = random(5, 15);
              const angle = random(TWO_PI);
              
              // Make straight-line cracks for pixel art style
              const x2 = x1 + cos(angle) * len;
              const y2 = y1 + sin(angle) * len;
              
              // Quantize to whole pixels for sharper look
              line(floor(x1), floor(y1), floor(x2), floor(y2));
            }
            
            // Warning effect when about to break
            if (p.crumbleTimer < p.crumbleMax * 0.3) {
              if (frameCount % 10 < 5) {
                stroke(255, 0, 0);
                strokeWeight(2);
                noFill();
                rect(p.x, p.y, p.w, p.h, 3);
              }
            }
          }
          
          pop();
        });
        
        noStroke();
      }

      function drawThings() {
        imageMode(CENTER);
        things.forEach((t) => {
          const bob = sin(frameCount * THING_BOB_SPEED + t.phase) * THING_BOB_AMPLITUDE;
          const sheet = t.collected ? thingSpriteSheet : thingSpriteSheetGrey;
          const col = t.frameIndex % THING_FRAMES_PER_ROW;
          const row = Math.floor(t.frameIndex / THING_FRAMES_PER_ROW);
          
          // Add colorful Bold & Bright style glow effect for collected things
          if (t.collected) {
            push();
            // Apply bold outline with glow effect
            drawingContext.shadowBlur = 10;
            drawingContext.shadowColor = STYLE.colors.yellow;
            
            // Add pixel-art style Bold & Bright effect
            strokeWeight(3);
            stroke(0);
            
            // Format: image(img, dx, dy, dw, dh, sx, sy, sw, sh)
            image(
              sheet,
              t.x, 
              t.y + bob, 
              t.size, 
              t.size,
              col * THING_FRAME_SIZE,
              row * THING_FRAME_SIZE,
              THING_FRAME_SIZE,
              THING_FRAME_SIZE
            );
            pop();
            
            // Add a shining star effect for collected things
            if (random() < 0.05) {
              const starX = t.x + random(-t.size/4, t.size/4);
              const starY = t.y + bob + random(-t.size/4, t.size/4);
              const starSize = random(5, 15);
              
              push();
              fill(255, 255, 100);
              stroke(0);
              strokeWeight(1);
              
              // Draw simple 4-point star
              beginShape();
              for (let i = 0; i < 8; i++) {
                const radius = i % 2 === 0 ? starSize : starSize * 0.4;
                const angle = i * PI / 4;
                const sx = starX + cos(angle) * radius;
                const sy = starY + sin(angle) * radius;
                vertex(sx, sy);
              }
              endShape(CLOSE);
              pop();
            }
          } else {
            // For uncollected things, draw with pixel-art style outline
            push();
            strokeWeight(2);
            stroke(0);
            
            // Format: image(img, dx, dy, dw, dh, sx, sy, sw, sh)
            image(
              sheet,
              t.x, 
              t.y + bob, 
              t.size, 
              t.size,
              col * THING_FRAME_SIZE,
              row * THING_FRAME_SIZE,
              THING_FRAME_SIZE,
              THING_FRAME_SIZE
            );
            pop();
          }
        });
      }

      function drawGoal() {
        rectMode(CORNER);
        
        // Bold & Bright style for the goal
        push();
        // Add pulsing glow effect
        const pulseAmount = sin(frameCount * 0.1) * 0.5 + 0.5; // 0-1 oscillation
        
        // Draw with bold outline
        fill(goal.color);
        strokeWeight(4);
        stroke(STYLE.colors.outlineColor);
        rect(goal.x, goal.y, goal.w, goal.h, 5); // Rounded corners
        
        // Draw a star pattern inside the goal
        noStroke();
        fill(255, 255, 255, 100 + pulseAmount * 50);
        
        // Draw a simple 4-point star
        const centerX = goal.x + goal.w/2;
        const centerY = goal.y + goal.h/2;
        const outerRadius = min(goal.w, goal.h) * (0.4 + pulseAmount * 0.05);
        const innerRadius = outerRadius * 0.4;
        
        beginShape();
        for (let i = 0; i < 8; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = i * PI / 4;
          const sx = centerX + cos(angle) * radius;
          const sy = centerY + sin(angle) * radius;
          vertex(sx, sy);
        }
        endShape(CLOSE);
        
        // Add "GOAL" text
        fill(255);
        stroke(0);
        strokeWeight(2);
        textSize(14);
        textStyle(BOLD);
        text("GOAL", centerX, centerY);
        textStyle(NORMAL);
        
        pop();
      }

      function drawNoggles() {
        imageMode(CENTER);
        noggles.forEach((n) => {
          push();
          translate(n.x, n.y);
          rotate(n.angle);
          const sz = n.r * 14;
          const offset = (sz / 48) * 8; // 8px offset at 48px base, scales with size

          // Add Bold & Bright style glow effect for noggles
          strokeWeight(3);
          stroke(0);
          
        

          image(noggleImg, offset, offset, sz, sz);
          pop();
        });
      }

      // Helper function for distance calculation
      function distToRectangle(px, py, rx, ry, rw, rh) {
        const nearestX = max(rx, min(px, rx + rw));
        const nearestY = max(ry, min(py, ry + rh));
        return dist(px, py, nearestX, nearestY);
      }

      function updateNoggles() {
        for (let i = noggles.length - 1; i >= 0; i--) {
          const n = noggles[i];
          n.vy += NOGGLE_GRAVITY;
          n.x += n.vx;
          n.y += n.vy;
          n.angle += n.angularVelocity;

          // Check for near misses with platforms (within 15px)
          for (const p of platforms) {
            const distToPlat = distToRectangle(n.x, n.y, p.x, p.y, p.w, p.h);

            if (distToPlat < 15 && distToPlat > 0) {
              // This is a near miss! Create "so close" particles
              for (let j = 0; j < 5; j++) {
                particles.push({
                  x: n.x,
                  y: n.y,
                  vx: random(-1, 1),
                  vy: random(-2, -0.5),
                  size: 3,
                  life: random(20, 30),
                  color: color(255, 255, 100, 200),
                  text: "Close!",
                });
              }
            }

            // Regular collision check
            if (n.x > p.x && n.x < p.x + p.w && n.y > p.y && n.y < p.h) {
              // Create satisfying burst particles
              for (let j = 0; j < 20; j++) {
                const ang = random(TWO_PI);
                particles.push({
                  x: n.x,
                  y: n.y,
                  vx: cos(ang) * random(1, 4),
                  vy: sin(ang) * random(1, 4),
                  size: random(3, 8),
                  life: random(15, 30),
                  color: color(random(200, 255), random(100, 200), random(50, 150), 200),
                });
              }

              p.color = activeBrightPalette[floor(random(activeBrightPalette.length))];
              if (window.FarcadeSDK?.singlePlayer) {
                window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
              }
              noggles.splice(i, 1);
              break;
            }
          }

          // Similar near-miss detection for things
          for (const t of things) {
            const distToThing = dist(n.x, n.y, t.x, t.y) - t.size / 2;

            // Near miss feedback for things
            if (!t.collected && distToThing < 20 && distToThing > 0) {
              // This is a near miss with a thing!
              for (let j = 0; j < 3; j++) {
                particles.push({
                  x: n.x,
                  y: n.y,
                  vx: random(-1, 1),
                  vy: random(-2, -0.5),
                  size: 3,
                  life: random(20, 30),
                  color: color(255, 200, 100, 200),
                  text: "Almost!",
                });
              }
            }

            // thing collision - keep existing code but add particle effects
            if (
              !t.collected &&
              n.x > t.x - t.size / 2 &&
              n.x < t.x + t.size / 2 &&
              n.y > t.y - t.size / 2 &&
              n.y < t.y + t.size / 2
            ) {
              // Create colorful burst on collection
              for (let j = 0; j < 25; j++) {
                const ang = random(TWO_PI);
                const particleDist = random(5, 15);
                particles.push({
                  x: t.x + cos(ang) * particleDist,
                  y: t.y + sin(ang) * particleDist,
                  vx: cos(ang) * random(1, 5),
                  vy: sin(ang) * random(-5, 1),
                  size: random(5, 10),
                  life: random(20, 40),
                  color: color(random(100, 255), random(100, 255), random(100, 255)),
                });
              }

              // Existing collection logic
              t.collected = true;
              score += 10;
              tagTimer = TAG_TIMER_MAX;
              if (window.FarcadeSDK?.singlePlayer) {
                window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
              }
              noggles.splice(i, 1);
              break;
            }
          }

          // out of bounds
          if (n.y > cameraY + height * 2) {
            noggles.splice(i, 1);
          }
        }
      }

      // New function for unified input handling
      function collectInputs() {
        const inputs = {
          moveLeft: false,
          moveRight: false,
          jump: false,
          throw: false,
          throwTarget: { x: 0, y: 0 },
          moveStrength: 1.0,
          jumpBuffered: jumpBufferTimer > 0,
        };

        // Keyboard inputs using global keyTracker (works regardless of canvas focus)
        // Using numeric key codes for arrow keys (LEFT=37, RIGHT=39, UP=38) along with WASD
        inputs.moveLeft = keyTracker.isKeyDown(37) || keyTracker.isKeyDown("a");
        inputs.moveRight = keyTracker.isKeyDown(39) || keyTracker.isKeyDown("d");
        inputs.jump = keyTracker.isKeyDown(38) || keyTracker.isKeyDown("w") || keyTracker.isKeyDown(32); // Space

        // Touch/mouse inputs
        for (const t of touches) {
          if (dist(t.x, t.y, joystick.x, joystick.y) < joystick.activeRadius) {
            const dx = t.x - joystick.x;
            inputs.moveLeft = inputs.moveLeft || dx < -joystick.inner / 2;
            inputs.moveRight = inputs.moveRight || dx > joystick.inner / 2;
            // Store analog value for variable speed
            inputs.moveStrength = constrain(abs(dx) / (joystick.outer - joystick.inner), 0, 1);
          }

          // Check for touch-based jump button presses
          if (dist(t.x, t.y, jumpBtn.x, jumpBtn.y) < jumpBtn.r) {
            inputs.jump = true;
          }
        }

        // If jump is detected through keyboard or touch, trigger the jump buffer
        if (inputs.jump && !previousJumpState) {
          jumpBufferTimer = 6;
          tryPerformJump();
        }

        // Track the previous jump state to detect new presses
        previousJumpState = inputs.jump;

        return inputs;
      }

      function updateJumpState() {
        // Decrement timers
        if (jumpBufferTimer > 0) jumpBufferTimer--;
        if (coyoteTimer > 0) coyoteTimer--;

        // Clear ground state when moving upward
        if (player.velocityY < -0.1) {
          player.isOnGround = false;
        }

        // Start coyote timer when walking off platforms
        if (!player.isOnGround && player.wasOnGround) {
          coyoteTimer = 8; // Slightly more generous (133ms at 60fps)
        }

        player.wasOnGround = player.isOnGround;
      }

      function tryPerformJump() {
        if ((player.isOnGround || coyoteTimer > 0) && jumpBufferTimer > 0) {
          player.velocityY = -15;
          player.isOnGround = false;
          coyoteTimer = 0;
          jumpBufferTimer = 0;

          // Keep timer for animation purposes but don't apply scaling
          player.jumpSquash = 1.5;

          // Enhanced jump particles for better visual feedback (since we're removing the squash)
          // Create a dust cloud effect at player's feet
          for (let i = 0; i < 15; i++) {
            const angle = random(PI / 6, (5 * PI) / 6);
            const speed = random(1, 4);
            particles.push({
              x: player.x + random(-10, 10),
              y: player.y + player.height / 2,
              vx: cos(angle) * speed * (random() > 0.5 ? -1 : 1),
              vy: -sin(angle) * speed,
              size: random(3, 8),
              life: random(15, 25),
              maxLife: 25,
              color: color(255, 255, 255, 180),
              type: "sparkle",
            });
          }

          // Add text effect occasionally
          if (random() < 0.3) {
            particles.push({
              x: player.x,
              y: player.y - 20,
              vx: 0,
              vy: -1.5,
              color: color(255, 255, 200),
              size: 1,
              life: 30,
              maxLife: 30,
              type: "text",
              text: "Jump!",
              textSize: 12,
            });
          }

          if (window.FarcadeSDK?.singlePlayer) {
            window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
          }
        }
      }

      function applyMovementPhysics(inputs) {
        // Target velocity based on input
        let targetVelocityX = 0;
        if (inputs.moveLeft) targetVelocityX = -5;
        if (inputs.moveRight) targetVelocityX = 5;

        // Apply analog control if using touch
        if (inputs.moveStrength !== undefined) {
          targetVelocityX *= inputs.moveStrength;
        }

        // Apply acceleration and deceleration for smoother movement
        const accelerationGround = 0.8;
        const accelerationAir = 0.4;
        const currentAccel = player.isOnGround ? accelerationGround : accelerationAir;

        if (targetVelocityX !== 0) {
          // Accelerating
          player.velocityX = lerp(player.velocityX, targetVelocityX, currentAccel);
        } else {
          // Decelerating (stop more quickly)
          player.velocityX *= 0.8;
          if (abs(player.velocityX) < 0.1) player.velocityX = 0;
        }

        // Update facing direction only when actually moving
        if (abs(targetVelocityX) > 0.1) {
          player.animation.facingDirection = targetVelocityX > 0 ? 1 : -1;
        }
      }

      function handlePlayerInput(inputs) {
        // Remove this entire block which is overriding velocityX
        // player.velocityX = 0;
        // if (inputs.moveLeft) {
        //   player.velocityX = -5;
        //   player.animation.facingDirection = -1;
        // }
        // if (inputs.moveRight) {
        //   player.velocityX = 5;
        //   player.animation.facingDirection = 1;
        // }
        // for (const t of touches) {
        //   if (dist(t.x, t.y, joystick.x, joystick.y) < joystick.activeRadius) {
        //     const dx = constrain(t.x - joystick.x, -(joystick.outer - joystick.inner), joystick.outer - joystick.inner);
        //     player.velocityX = dx > 0 ? 5 : -5;
        //     player.animation.facingDirection = dx > 0 ? 1 : -1;
        //     break;
        //   }
        // }

        // Keep just the jump handling part
        for (const t of touches) {
          if (dist(t.x, t.y, jumpBtn.x, jumpBtn.y) < jumpBtn.r) {
            jumpBufferTimer = 6;
            tryPerformJump();
            break;
          }
        }
      }

      function tryPerformJump() {
        if ((player.isOnGround || coyoteTimer > 0) && jumpBufferTimer > 0) {
          player.velocityY = -15;
          player.isOnGround = false;
          coyoteTimer = 0;
          jumpBufferTimer = 0;

          // Keep timer for animation purposes but don't apply scaling
          player.jumpSquash = 1.5;

          // Enhanced jump particles for better visual feedback
          // Create a dust cloud effect at player's feet
          for (let i = 0; i < 15; i++) {
            const angle = random(PI / 6, (5 * PI) / 6);
            const speed = random(1, 4);
            particles.push({
              x: player.x + random(-10, 10),
              y: player.y + player.height / 2,
              vx: cos(angle) * speed * (random() > 0.5 ? -1 : 1),
              vy: -sin(angle) * speed,
              size: random(3, 8),
              life: random(15, 25),
              maxLife: 25,
              color: color(255, 255, 255, 180),
              type: "sparkle",
            });
          }

          // Add text effect occasionally
          if (random() < 0.3) {
            particles.push({
              x: player.x,
              y: player.y - 20,
              vx: 0,
              vy: -1.5,
              color: color(255, 255, 200),
              size: 1,
              life: 30,
              maxLife: 30,
              type: "text",
              text: "Jump!",
              textSize: 12,
            });
          }

          if (window.FarcadeSDK?.singlePlayer) {
            window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
          }
        }
      }

      function updatePlayer() {
        // Store the previous platform the player was on
        // This helps us detect when we've just landed on a new platform
        const previousPlatform = player.platformBelow;
        player.platformBelow = null;

        // Apply normal horizontal movement
        player.x += player.velocityX;

        // First handle horizontal collisions
        platforms.forEach((p) => {
          if (isColliding(player, p)) {
            // Don't resolve horizontal collision for moving platforms when standing on top
            if (p.type === "moving" && player.isOnGround && player.y <= p.y + 1) {
              // We'll handle this below with platform movement
            } else {
              // Normal horizontal collision
              if (player.velocityX > 0) {
                player.x = p.x - player.width / 2;
              } else {
                player.x = p.x + p.w + player.width / 2;
              }
              player.velocityX = 0;
            }
          }
        });

        // Update coyote time and jump buffer
        if (!player.isOnGround) coyoteTimer = max(coyoteTimer - 1, 0);
        if (jumpBufferTimer > 0) jumpBufferTimer--;
        if (player.isOnGround && jumpBufferTimer > 0) tryPerformJump();

        // Apply gravity and vertical movement
        player.velocityY += 0.5;
        player.y += player.velocityY;
        player.isOnGround = false;

        // Handle platform collisions and special platform behaviors
        platforms.forEach((p) => {
          if (isColliding(player, p)) {
            const prevBot = player.y - player.velocityY + player.height / 2;

            if (player.velocityY > 0 && prevBot <= p.y + 1) {
              // Landing on top of platform
              player.y = p.y - player.height / 2;
              player.platformBelow = p; // Track which platform player is on

              // Handle platform-specific landing behaviors
              switch (p.type) {
                case "crumbling":
                  // Existing crumbling platform code...
                  if (p.crumbleTimer === -1) {
                    p.crumbleTimer = p.crumbleMax;

                    // Create crumbling particles...
                    for (let i = 0; i < 5; i++) {
                      particles.push({
                        x: player.x + random(-10, 10),
                        y: p.y,
                        vx: random(-1, 1),
                        vy: random(-1, -0.2),
                        color: color(p.color),
                        size: random(3, 6),
                        life: 15,
                        maxLife: 15,
                        type: "debris",
                        angle: random(TWO_PI),
                        rotationSpeed: random(-0.1, 0.1),
                      });
                    }

                    // Add "Cracking!" text effect
                    particles.push({
                      x: player.x,
                      y: player.y - 25,
                      vx: 0,
                      vy: -1,
                      color: color(255, 100, 50),
                      size: 2,
                      life: 30,
                      maxLife: 30,
                      type: "text",
                      text: "Cracking!",
                      textSize: 12,
                    });
                  }
                  break;

                case "bouncy":
                  // Compress spring and apply bounce
                  p.springCompression = 5;
                  player.velocityY = -15 * p.bounceFactor; // Apply moderately higher jump

                  // In higher difficulty zones, add some horizontal momentum too
                  if (p.zoneDifficulty > 0.7 && !p.isTutorial) {
                    const horizontalBoostFactor = map(p.zoneDifficulty, 0.7, 1.0, 0.3, 0.8);

                    // Determine direction based on player's position on the platform
                    const playerPosOnPlat = (player.x - p.x) / p.w;

                    // Higher boost when near edges, minimal in center
                    const edgeFactor = abs(playerPosOnPlat - 0.5) * 2; // 0 at center, 1 at edges
                    const boostMagnitude = 4 * horizontalBoostFactor * edgeFactor;

                    // Apply horizontal boost away from center
                    if (playerPosOnPlat < 0.5) {
                      // Left side - boost left
                      player.velocityX = -boostMagnitude;
                    } else {
                      // Right side - boost right
                      player.velocityX = boostMagnitude;
                    }

                    // Add side-boost indicator for advanced zone bouncy platforms
                    if (edgeFactor > 0.6) {
                      const boostDirection = playerPosOnPlat < 0.5 ? "←" : "→";
                      particles.push({
                        x: player.x,
                        y: player.y - 35,
                        vx: player.velocityX * 0.1,
                        vy: -1.5,
                        color: color(255, 220, 100),
                        size: 2,
                        life: 30,
                        maxLife: 30,
                        type: "text",
                        text: boostDirection + " BOOST!",
                        textSize: 14,
                      });
                    }
                  }

                  // Add bounce particles
                  for (let i = 0; i < 12; i++) {
                    const angle = random(-PI / 4, (-3 * PI) / 4);
                    particles.push({
                      x: player.x + random(-10, 10),
                      y: player.y + player.height / 2 - 5,
                      vx: cos(angle) * random(1, 3),
                      vy: sin(angle) * random(1, 3),
                      color: color(255, 255, 100),
                      size: random(3, 8),
                      life: 25,
                      maxLife: 25,
                      type: "sparkle",
                    });
                  }

                  // Add bounce text effect - bigger and more noticeable
                  particles.push({
                    x: player.x,
                    y: player.y - 25,
                    vx: 0,
                    vy: -2,
                    color: color(255, 220, 0),
                    size: 2,
                    life: 40,
                    maxLife: 40,
                    type: "text",
                    text: "BOING!",
                    textSize: 16,
                  });
                  break;

                // Vertical platform type has been removed

                case "moving":
                  // Store current position for next frame's velocity calculation
                  if (p.prevX === undefined) {
                    p.prevX = p.x;
                  }
                  break;
              }

              // Common landing behavior
              if (p.type !== "bouncy") {
                player.velocityY = 0;
              }

              player.isOnGround = true;
              coyoteTimer = 6;
            } else {
              // Hitting platform from below or side
              if (player.velocityY < 0) player.velocityY = 0;
              player.y = p.y + p.h + player.height / 2;

              // Ensure we don't stick to the bottom of the platform
              if (player.platformBelow === p) {
                player.platformBelow = null;
              }
            }
          }
        });

        // Apply platform movement - this is the key to fixing the issues
        // We do this AFTER regular physics to ensure player stays attached
        if (player.isOnGround && player.platformBelow) {
          const p = player.platformBelow;

          // Handle horizontal movement for moving platforms
          if (p.type === "moving") {
            // If this is the first frame we've landed on this platform,
            // just initialize the prevX value without moving the player
            if (p.prevX === undefined || player.platformBelow !== previousPlatform) {
              p.prevX = p.x;
            } else {
              const platformDeltaX = p.x - p.prevX;
              // Apply platform's horizontal movement directly to player position
              player.x += platformDeltaX;
            }
            p.prevX = p.x;
          }

          // Vertical platforms have been removed from the game
        }

        // Keep player within level bounds
        player.x = constrain(player.x, player.width / 2, levelWidth - player.width / 2);
      }

      function updatePlayerAnimationState() {
        let set = player.animation.currentSet;
        if (player.velocityY < -0.1 && !player.isOnGround) set = "jump";
        else if (player.velocityY > 0.1 && !player.isOnGround) set = "fall";
        else if (player.isOnGround && abs(player.velocityX) > 0.1) set = "walk";
        else if (player.isOnGround) set = "idle";
        if (set !== player.animation.currentSet) {
          player.animation.currentSet = set;
          player.animation.frameIndex = 0;
          player.animation.tick = 0;
        }
      }

      function advancePlayerFrame() {
        const def = ANIMATION_DEFS[player.animation.currentSet];
        if (!def) return;
        player.animation.tick++;
        if (player.animation.tick >= def.speed) {
          player.animation.tick = 0;
          player.animation.frameIndex = (player.animation.frameIndex + 1) % def.frames;
        }
      }

      function drawPlayer() {
        if (!player.spriteSheet) {
          push();
          rectMode(CENTER);
          fill(255, 0, 0);
          rect(player.x, player.y, player.width, player.height);
          pop();
          return;
        }
        const a = player.animation;
        const dir = a.facingDirection === 1 ? "right" : "left";
        const animMap = ANIMATION_MAP[a.currentSet][dir];
        const frame = a.frameIndex % ANIMATION_DEFS[a.currentSet].frames;
        const sx = (animMap.startFrame + frame) * FRAME_WIDTH;
        const sy = animMap.row * FRAME_HEIGHT;

        // Use consistent 2.5 scale for character - maintains proportions in all animations
        const playerScale = 2.5;
        const dw = FRAME_WIDTH * playerScale;
        const dh = FRAME_HEIGHT * playerScale;

        push();
        translate(player.x, player.y);

        // Keep track of jump animation state but don't apply squash/stretch scaling
        if (player.jumpSquash > 0) {
          player.jumpSquash = max(player.jumpSquash - 0.1, 0);
        }

        // Apply throw animation rotation only (no scaling)
        if (player.throwSquash > 0) {
          rotate(player.animation.facingDirection * customMap(player.throwSquash, 1, 0, PI / 16, 0));
          player.throwSquash = max(player.throwSquash - 0.15, 0);
        }

        const yoff = (dh - player.height) / 2;
        image(player.spriteSheet, 0, -yoff, dw, dh, sx, sy, FRAME_WIDTH, FRAME_HEIGHT);
        pop();
      }

      function drawUI() {
        // Draw joystick and jump controls
        noFill();
        stroke(0, 0, 100, 50);
        strokeWeight(2);
        circle(joystick.x, joystick.y, joystick.outer * 2);
        let kx = joystick.x;
        for (const t of touches) {
          if (dist(t.x, t.y, joystick.x, joystick.y) < joystick.activeRadius) {
            kx += constrain(t.x - joystick.x, -(joystick.outer - joystick.inner), joystick.outer - joystick.inner);
            break;
          }
        }
        noStroke();
        fill(0, 0, 100, 80);
        circle(kx, joystick.y, joystick.inner * 2);
        fill(0, 0, 100, 20);
        circle(jumpBtn.x, jumpBtn.y, jumpBtn.r * 2);
        fill(0, 0, 100, 80);
        textSize(24);
        text("↑", jumpBtn.x, jumpBtn.y + 2);

        // Draw score
        noStroke();
        fill(0, 0, 100);
        textSize(24);
        textAlign(CENTER, TOP);
        text(`Score: ${score}`, width / 2, 10);

        // Section name and platform indicators have been removed for a cleaner UI
        
        // Reset text alignment
        textAlign(CENTER, CENTER);
      }

      function isColliding(a, b) {
        const l1 = a.x - a.width / 2,
          r1 = a.x + a.width / 2,
          t1 = a.y - a.height / 2,
          b1 = a.y + a.height / 2,
          l2 = b.x,
          r2 = b.x + b.w,
          t2 = b.y,
          b2 = b.y + b.h;
        return r1 > l2 && l1 < r2 && b1 > t2 && t1 < b2;
      }

      function displayStartScreen() {
  // 1️⃣ draw the full‑canvas background image
  push();
  imageMode(CORNER);
  noTint();
  image(titleBg, 0, 0, width, height);
  pop();
  
  // ===== CHARACTER PREVIEW SECTION =====
  // Create semi-transparent area for character preview
  fill(0, 0, 0, 80);
  rectMode(CENTER);
  rect(width / 2, height * 0.35, 200, 200, 10);
  
  // Draw character preview (animated walking character)
  push();
  translate(width / 2, height * 0.34);
  
  // Use the current spritesheet (prioritize custom over default)
  const previewSpriteSheet = customPlayerSpriteSheet || (player ? player.spriteSheet : null) || nounSpriteSheet;
  if (previewSpriteSheet) {
    // Walking animation - right facing
    const animIdx = floor(frameCount / 6) % 8; // Animation speed and frames
    const row = 0; // Walk animation row
    const sx = animIdx * FRAME_WIDTH;
    const sy = row * FRAME_HEIGHT;
    
    // Draw at a good preview size
    image(previewSpriteSheet, 0, 0, 200, 200, sx, sy, FRAME_WIDTH, FRAME_HEIGHT);
  } else {
    // Fallback if spritesheet isn't loaded
    fill(255, 0, 0);
    rect(0, 0, 48, 48);
  }
  pop();
  
  // ===== CHARACTER BUTTONS SECTION =====
  // Create "Randomize" button
  fill(STYLE.colors.blue);
  stroke(0);
  strokeWeight(3);
  rectMode(CENTER);
  rect(width / 2 - 70, height * 0.5, 120, 45, 10);
  
  // Create "Customize" button
  fill(STYLE.colors.yellow);
  rect(width / 2 + 70, height * 0.5, 120, 45, 10);
  
  // Button text
  fill(255);
  strokeWeight(2);
  textSize(18);
  textAlign(CENTER, CENTER);
  text("RANDOMIZE", width / 2 - 70, height * 0.5);
  text("CUSTOMIZE", width / 2 + 70, height * 0.5);
  
  // Reset styles
  strokeWeight(1);
  rectMode(CORNER);
  
  // calculate Y positions
  const startY = height - 10; // bottom edge for "Tap to Start"
  const throwY = startY - 50; // throw Noggles
  const jumpY = startY - 75; // jump
  const moveY = startY - 100; // move left/right

  // — Instructions just above the start prompt —
  textFont("Roboto");
  textSize(20);
  fill("#000000");
  textStyle(BOLD);
  textAlign(CENTER, CENTER);
  text("← → or A / D: Move", width / 2, moveY - 80);
  text("↑ or W: Jump", width / 2, jumpY - 80);
  text("Click / Tap to Throw Noggles", width / 2, throwY - 80);

  // Reset alignment
  textAlign(CENTER, CENTER);

  // — "Start" prompt at the very bottom —
  textSize(24);
  textAlign(CENTER, BOTTOM);
  text("Tap or Click to Start", width / 2, startY);
  textStyle(NORMAL);
}

      function checkGoal() {
        if (isColliding(player, goal)) {
          console.log("[DEBUG] checkGoal → win", {
            playerPos: { x: player.x, y: player.y },
            goalPos: goal,
            score,
            gameStateBefore: gameState,
          });
          gameState = "win";
        }
      }

      function checkFallen() {
        // if player falls off bottom of screen…
        if (player.y - player.height / 2 > cameraY + height * 2) {
          console.log("[DEBUG] checkFallen → gameOver", {
            playerY: player.y,
            cameraY,
            threshold: cameraY + height * 2,
            score,
            gameStateBefore: gameState,
          });

          // spawn the final noggle…
          noggles.push({
            x: player.x,
            y: player.y - FRAME_HEIGHT * 1.5,
            vx: 0,
            vy: -NOGGLE_MAX_SPEED,
            r: 10,
            angle: 0,
            angularVelocity: random(-0.2, 0.2),
          });

          gameState = "gameOver";
        }
      }

      function keyPressed() {
        if (gameState === "playing") {
          // The actual key checking is now handled by the global keyTracker in collectInputs
          // We only need to handle jump buffering here
          // UP_ARROW=38, W=87, SPACE=32
          if ([38, 87, 32].includes(keyCode)) {
            jumpBufferTimer = 6;
            tryPerformJump();
          }

          // Debug mode toggle (D key)
          if (keyCode === 68) {
            // 'D' key (keyCode 68)
            debugMode = !debugMode;
            console.log("Debug mode: " + (debugMode ? "ON" : "OFF"));
          }

          // Zone teleport in debug mode
          if (debugMode && keyCode >= 49 && keyCode <= 53) {
            // Number keys 1-5
            const zoneIndex = keyCode - 49; // 0-4
            teleportToZone(zoneIndex);
          }
        }

        // Don't prevent default for canvas refocusing to work properly
        return true;
      }

      // Function to teleport player to a specific zone (for debugging)
      function teleportToZone(zoneIndex) {
        let targetX = 0;

        // Calculate target position based on zone
        switch (zoneIndex) {
          case 0: // Normal platforms zone - beginning
            targetX = LEVEL_LENGTH * 0.005;
            break;
          case 1: // Bouncy platforms zone
            targetX = LEVEL_LENGTH * (INTRO_ZONES.bouncy.start + 0.01);
            break;
          case 2: // Moving platforms zone
            targetX = LEVEL_LENGTH * (INTRO_ZONES.moving.start + 0.01);
            break;
          case 3: // Crumbling platforms zone
            targetX = LEVEL_LENGTH * (INTRO_ZONES.crumbling.start + 0.01);
            break;
          case 4: // Mixed zone
            targetX = LEVEL_LENGTH * (INTRO_ZONES.mixed.start + 0.01);
            break;
        }

        // Find a suitable platform near the target X position
        const nearbyPlatforms = platforms.filter((p) => p.x > targetX - 200 && p.x < targetX + 1000);

        if (nearbyPlatforms.length > 0) {
          // Sort by distance to target X
          nearbyPlatforms.sort((a, b) => Math.abs(a.x - targetX) - Math.abs(b.x - targetX));

          // Position player on top of the nearest platform
          const platform = nearbyPlatforms[0];
          player.x = platform.x + platform.w / 2;
          player.y = platform.y - player.height / 2;
          player.velocityY = 0;
          player.velocityX = 0;

          // Reset tag timer when teleporting
          tagTimer = TAG_TIMER_MAX;

          console.log(`Teleported to zone ${zoneIndex + 1} at position ${Math.round(player.x)}`);
        } else {
          console.log(`Could not find suitable platform in zone ${zoneIndex + 1}`);
        }
      }

      function generateRandomCharacter() {
  // Get a reference to the character creator iframe
  const iframe = document.getElementById('characterCreatorFrame');
  
  if (iframe && iframe.contentWindow) {
    // Post a message to the character creator iframe asking for a random character
    iframe.contentWindow.postMessage({ 
      type: 'generateRandom' 
    }, '*');
    
    // Show a loading indicator
    const loadingMsg = document.createElement('div');
    loadingMsg.textContent = "Generating character...";
    loadingMsg.id = "character-loading";
    loadingMsg.style = "position:fixed; top:20px; left:50%; transform:translateX(-50%); background:#1929F4; color:white; padding:10px; border-radius:5px; z-index:1000";
    document.body.appendChild(loadingMsg);
    
    // The response will come through the same message event listener
    // that's already set up for the character creator
    console.log("Requested random character from character creator");
  } else {
    console.error("Character creator iframe not found");
  }
}

      function mousePressed() {
  // Check if this is actually a touch event on mobile
  if (touches && touches.length > 0) {
    return false; // Skip processing if it's actually a touch event
  }

  // Always ensure keyboard focus on all mouse clicks
  document.querySelector("canvas").focus();

  if (gameState === "start") {
    // Check for RANDOMIZE button click
    if (
      mouseX > width / 2 - 130 && mouseX < width / 2 - 10 &&
      mouseY > height * 0.5 - 22.5 && mouseY < height * 0.5 + 22.5
    ) {
      // Generate new random character
      generateRandomCharacter();
      return false;
    }
    
    // Check for CUSTOMIZE button click
    if (
      mouseX > width / 2 + 10 && mouseX < width / 2 + 130 &&
      mouseY > height * 0.5 - 22.5 && mouseY < height * 0.5 + 22.5
    ) {
      document.getElementById('characterCreatorModal').style.display = 'block';
      return false;
    }

    // Any other click on start screen starts the game
    initializeGame();
    gameState = "playing";
    return false;
  }

  if (gameState === "playing") {
    // Use our improved throw handler
    handleThrowInput(mouseX, mouseY);
  }
  return false; // Prevent default
}

      function touchStarted() {
  // If the character creator modal is open, do nothing
  if (document.getElementById('characterCreatorModal').style.display === 'block') {
    return false;
  }

  if (gameState === "start" && touches.length > 0) {
    const t = touches[0];
    
    // Check for "Randomize" button tap
    if (
      t.x > width / 2 - 130 && t.x < width / 2 - 10 &&
      t.y > height * 0.5 - 22.5 && t.y < height * 0.5 + 22.5
    ) {
      // Generate new random character
      generateRandomCharacter();
      return false;
    }
    
    // Check for "Customize" button tap
    if (
      t.x > width / 2 + 10 && t.x < width / 2 + 130 &&
      t.y > height * 0.5 - 22.5 && t.y < height * 0.5 + 22.5
    ) {
      document.getElementById('characterCreatorModal').style.display = 'block';
      return false; // Prevent further processing
    }

    // If not touching buttons, start the game
    initializeGame();
    gameState = "playing";
    // Also focus canvas on touch start to enable keyboard fallbacks
    document.querySelector("canvas").focus();
    return false;
  }

  if (gameState === "playing") {
    const t = touches[touches.length - 1];

    // Store the touch ID to track it
    if (t && t.id !== undefined) {
      activeTouchIds[t.id] = {
        startX: t.x,
        startY: t.y,
        time: millis(),
      };
    }

    if (dist(t.x, t.y, jumpBtn.x, jumpBtn.y) <= jumpBtn.r) {
      jumpBufferTimer = 6;
      tryPerformJump();
      return false;
    }

    // Use our improved throw handler - only on touchStart
    if (handleThrowInput(t.x, t.y)) {
      return false;
    }

    return false;
  }
  return false;
}

      // Add touchEnded handler to prevent double throws
      function touchEnded() {
        // We never want to throw on touch end - ignore the event completely for throw purposes

        // Clean up the touch tracking if we have an ID
        if (touches.length > 0) {
          const t = touches[touches.length - 1];
          if (t && t.id !== undefined) {
            delete activeTouchIds[t.id];
          }
        }

        return false;
      }

      function handleThrowInput(mx, my) {
        // Apply debounce - prevent rapid consecutive throws
        const currentTime = millis();
        if (currentTime - lastThrowTime < THROW_COOLDOWN) {
          return false; // Too soon since last throw
        }

        // Handle touch type detection - only allow throws on initial touch
        if (touches && touches.length > 0) {
          // This is a touch-sourced event
          let touchEvent = false;

          for (let i = 0; i < touches.length; i++) {
            const t = touches[i];
            // Check if this is a new touch or a moved touch
            if (t.id !== undefined && activeTouchIds[t.id]) {
              const touchInfo = activeTouchIds[t.id];

              // If this touch has moved a lot, it might be trying to control the joystick
              // so don't treat it as a throw attempt
              const moveDistance = dist(t.x, t.y, touchInfo.startX, touchInfo.startY);
              if (moveDistance > 20) {
                return false;
              }

              touchEvent = true;
            }
          }

          // If it's not from our trackable touch events, don't allow the throw
          if (!touchEvent) {
            return false;
          }
        }

        // Is this a valid throw input?
        if (
          dist(mx, my, joystick.x, joystick.y) <= joystick.activeRadius ||
          dist(mx, my, jumpBtn.x, jumpBtn.y) <= jumpBtn.r
        ) {
          return false; // Don't throw if clicking controls
        }

        // Calculate world coordinates
        const wsx = player.x;
        const wsy = player.y - FRAME_HEIGHT * 1.5; // Throw from higher point
        const wex = cameraX + mx;
        const wey = cameraY + my;

        // Calculate direction and power
        const dxRaw = wex - wsx;
        const dyRaw = wey - wsy;
        const distRaw = sqrt(dxRaw * dxRaw + dyRaw * dyRaw);

        // Add minimum throw distance to ensure intentionality
        if (distRaw < 20) return false;

        const eff = min(distRaw, NOGGLE_MAX_DISTANCE);
        const speed = customMap(eff, 0, NOGGLE_MAX_DISTANCE, NOGGLE_MAX_SPEED * 0.5, NOGGLE_MAX_SPEED);
        const angle = atan2(dyRaw, dxRaw);
        const dx = cos(angle) * speed;
        const dy = sin(angle) * speed;

        // Add trail particles for the noggle
        const noggleColor = color(255, 50, 50, 150);

        // Create throw with proper initial velocity and enhanced properties
        noggles.push({
          x: wsx,
          y: wsy,
          vx: dx,
          vy: dy,
          r: 10,
          angle: angle, // Start at angle of throw
          angularVelocity: random(-0.3, 0.3), // More rotation variation
          throwFrame: frameCount, // Track when thrown for effects
          hasTrail: true, // Flag to enable particle trail
          trailColor: noggleColor, // Store the trail color
        });

        // Add throw animation to player with more dramatic effect
        player.throwSquash = 1.5; // Increased for more visual impact

        // Create throw particles
        for (let i = 0; i < 12; i++) {
          const particleAngle = angle + random(-0.5, 0.5);
          const particleSpeed = random(1, 5);
          particles.push({
            x: wsx,
            y: wsy,
            vx: cos(particleAngle) * particleSpeed,
            vy: sin(particleAngle) * particleSpeed,
            size: random(2, 6),
            life: random(10, 25),
            color: noggleColor,
          });
        }

        // Provide feedback
        if (window.FarcadeSDK?.singlePlayer) {
          window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
        }

        // Update the last throw time for debouncing
        lastThrowTime = currentTime;

        return true;
      }

      // Optional audio mute control
      function setMuted(isMuted) {
        // implement pausing/resuming audio
      }
    </script>
    <div id="characterCreatorModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8);">
    <div style="position: relative; width: 90%; max-width: 800px; height: 90%; margin: 2% auto; background: white; overflow: hidden;">
      <span onclick="document.getElementById('characterCreatorModal').style.display='none'" 
            style="position: absolute; right: 15px; top: 10px; font-size: 24px; cursor: pointer; z-index: 1001;">&times;</span>
      <iframe id="characterCreatorFrame" style="width: 100%; height: 100%; border: none;" 
              src="https://dannywalter.github.io/Nounify-the-World/assetz/charactercreator.html"></iframe>
    </div>
  </div>
</body>
</html>